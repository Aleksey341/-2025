/* ========================================
   CONFIG
   ======================================== */

const PAGES_BASE_URL = 'https://aleksey341.github.io/-2025';

// Папки регионов у вас в корне репозитория: /Samara/01.png
// Если перенесёте в /slides/<Region>/01.png → поставьте 'slides'
const SLIDES_ROOT_DIR = ''; // '' | 'slides'

const SLIDE_EXT = 'png';
const SLIDE_PAD = 2;
const SLIDE_MAX_TRY = 200;

const WISH_PAGE_URL = 'https://aleksey341.github.io/-2025/wish.html';
const QR_IMAGE_URL = './qr.png';

/* ========================================
   GLOBAL STATE
   ======================================== */
let db;
let slidesData = {};              // { regionId: [ {name, data(url)} ] }
let viewedRegions = new Set();
let currentRegion = null;
let currentSlideIndex = 0;
let isSplitMode = false;
let isFirstLoad = true;

let finalScreenInterval = null;
let floatingWishesInterval = null;

// чтобы не было параллельных скачиваний одного региона
const downloadInFlight = new Map(); // regionId -> Promise

// Короткий набор для фона финального экрана (можете расширять)
const wishesForAnimation = [
  "Пусть в новом году будет больше ясности",
  "Пусть решения приходят вовремя",
  "Пусть рядом будут надёжные люди",
  "Пусть дом будет тёплым и спокойным",
  "Пусть деньги приходят легко и честно",
  "Пусть работа радует результатом",
  "Пусть силы восстанавливаются быстрее",
  "Пусть любовь будет взаимной",
  "Пусть планы реализуются без суеты",
  "Пусть год будет щедрым на хорошие новости"
];

/* ========================================
   REGIONS
   slotClass — это ВАШИ существующие классы под CSS-сетку (как было)
   id — имя папки в репозитории (Samara/SPB/NN/…)
   ======================================== */

const regions = [
  { id: 'SPB',         slotClass: 'region1',     name: 'Санкт-Петербург',   code: '#78', ornament: 'spb' },
  { id: 'Novosib',     slotClass: 'region2',     name: 'Новосибирск',       code: '#54', ornament: 'novosib' },
  { id: 'Samara',      slotClass: 'region3',     name: 'Самара',            code: '#63', ornament: 'samara' },
  { id: 'Arhangelsk',  slotClass: 'region4',     name: 'Архангельск',       code: '#29', ornament: 'arhangelsk' },

  { id: 'Vladivostok', slotClass: 'vladivostok', name: 'Владивосток',       code: '#25', ornament: 'vladivostok' },
  { id: 'Jamal',       slotClass: 'yanao',       name: 'ЯНАО',              code: '#89', ornament: 'yanao' },
  { id: 'NN',          slotClass: 'nn',          name: 'Нижний Новгород',   code: '#52', ornament: 'nn' },
  { id: 'Krasnodar',   slotClass: 'krasnodar',   name: 'Краснодар',         code: '#23', ornament: 'krasnodar' }
];

const kirovRegion = {
  id: 'Kirovskaja',    // имя папки
  slotClass: 'kirov',  // ваш CSS-класс под split
  name: 'Кировская область',
  code: '#43',
  ornament: 'kirovskaja'
};

/* ========================================
   HELPERS
   ======================================== */
function $(id) { return document.getElementById(id); }
function to2(n) { return String(n).padStart(SLIDE_PAD, '0'); }

function buildSlideUrl(regionId, index1based) {
  const file = `${to2(index1based)}.${SLIDE_EXT}`;
  const parts = [PAGES_BASE_URL];
  if (SLIDES_ROOT_DIR) parts.push(SLIDES_ROOT_DIR);
  parts.push(regionId, file);
  return parts.join('/').replace(/([^:]\/)\/+/g, '$1');
}

function hasSlides(regionId) {
  return Array.isArray(slidesData[regionId]) && slidesData[regionId].length > 0;
}

function getTotalRegionsCount() {
  return regions.length + (isSplitMode ? 1 : 0);
}

/* ========================================
   INDEXEDDB
   ======================================== */
function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('PresentationDB', 3);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => { db = request.result; resolve(db); };

    request.onupgradeneeded = (event) => {
      db = event.target.result;
      if (!db.objectStoreNames.contains('slides')) {
        db.createObjectStore('slides', { keyPath: 'regionId' });
      }
      if (!db.objectStoreNames.contains('progress')) {
        db.createObjectStore('progress', { keyPath: 'id' });
      }
    };
  });
}

async function saveSlidesToDB(regionId) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(['slides'], 'readwrite');
    const store = tx.objectStore('slides');
    const request = store.put({ regionId, slides: slidesData[regionId] || [] });
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

async function loadSlidesFromDB() {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(['slides'], 'readonly');
    const store = tx.objectStore('slides');
    const request = store.getAll();

    request.onsuccess = () => {
      const results = request.result || [];
      results.forEach(item => {
        if (item.slides && item.slides.length) {
          slidesData[item.regionId] = item.slides.map(s =>
            typeof s === 'string' ? { name: '', data: s } : s
          );
          slidesData[item.regionId].sort((a, b) =>
            (a?.name || '').localeCompare((b?.name || ''), undefined, { numeric: true })
          );
        }
      });
      resolve();
    };
    request.onerror = () => reject(request.error);
  });
}

async function saveProgressToDB() {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(['progress'], 'readwrite');
    const store = tx.objectStore('progress');
    const request = store.put({ id: 'viewedRegions', regions: Array.from(viewedRegions) });
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

async function loadProgressFromDB() {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(['progress'], 'readonly');
    const store = tx.objectStore('progress');
    const request = store.get('viewedRegions');
    request.onsuccess = () => {
      if (request.result?.regions) viewedRegions = new Set(request.result.regions);
      resolve();
    };
    request.onerror = () => reject(request.error);
  });
}

async function saveSplitModeToDB() {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(['progress'], 'readwrite');
    const store = tx.objectStore('progress');
    const request = store.put({ id: 'splitMode', value: !!isSplitMode });
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

async function loadSplitModeFromDB() {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(['progress'], 'readonly');
    const store = tx.objectStore('progress');
    const request = store.get('splitMode');
    request.onsuccess = () => { isSplitMode = !!request.result?.value; resolve(); };
    request.onerror = () => reject(request.error);
  });
}

/* ========================================
   DOWNLOAD SLIDES FROM PAGES
   ======================================== */
async function urlExists(url) {
  try {
    const r = await fetch(url, { method: 'HEAD', cache: 'no-store' });
    return r.ok;
  } catch (_) {
    try {
      const r2 = await fetch(url, { method: 'GET', cache: 'no-store' });
      return r2.ok;
    } catch (__) {
      return false;
    }
  }
}

async function downloadRegionSlides(regionId, { onProgress } = {}) {
  const collected = [];
  for (let i = 1; i <= SLIDE_MAX_TRY; i++) {
    const url = buildSlideUrl(regionId, i);
    const ok = await urlExists(url);
    if (!ok) break;
    collected.push({ name: `${to2(i)}.${SLIDE_EXT}`, data: url });
    if (typeof onProgress === 'function') onProgress({ loaded: collected.length });
  }
  return collected;
}

function setCardBackStatus(cardEl, text) {
  const status = cardEl?.querySelector('.card-status');
  if (status) status.textContent = text;
}

async function ensureSlidesLoaded(regionId, cardEl) {
  if (hasSlides(regionId)) return;

  if (downloadInFlight.has(regionId)) {
    setCardBackStatus(cardEl, '⏳ Загрузка…');
    await downloadInFlight.get(regionId);
    return;
  }

  const p = (async () => {
    setCardBackStatus(cardEl, '⏳ Загрузка…');

    const slides = await downloadRegionSlides(regionId, {
      onProgress: ({ loaded }) => setCardBackStatus(cardEl, `⏳ Загрузка… (${loaded})`)
    });

    if (!slides.length) {
      throw new Error(`Не найдено слайдов в папке ${regionId}. Ожидаю 01.${SLIDE_EXT}, 02.${SLIDE_EXT}…`);
    }

    slidesData[regionId] = slides;
    await saveSlidesToDB(regionId);
  })();

  downloadInFlight.set(regionId, p);

  try {
    await p;
  } finally {
    downloadInFlight.delete(regionId);
  }
}

/* ========================================
   BENTO CARDS
   ======================================== */
function createRegionCards() {
  const grid = $('bentoGrid');
  if (!grid) return;

  grid.innerHTML = '';
  grid.classList.toggle('split-mode', !!isSplitMode);

  let cardIndex = 0;

  regions.forEach(region => {
    if (isSplitMode && region.id === 'Vladivostok') {
      createSplitCard(grid, region, true, cardIndex); cardIndex++;
      createSplitCard(grid, kirovRegion, false, cardIndex); cardIndex++;
      return;
    }

    createRegionCard(grid, region, false, cardIndex);
    cardIndex++;
  });

  if (isFirstLoad) setTimeout(() => { isFirstLoad = false; }, 800);
}

function createRegionCard(grid, region, forceInactive = false, cardIndex = 0) {
  const item = document.createElement('div');

  // ВАЖНО: slotClass — чтобы CSS-сетка вернулась как было
  item.className = `bento-item ${region.slotClass}${isFirstLoad ? ' animate-in' : ''}`;
  item.dataset.regionId = region.id;

  if (isFirstLoad) item.style.setProperty('--appear-delay', `${cardIndex * 0.1}s`);

  if (viewedRegions.has(region.id) || forceInactive) item.classList.add('viewed');

  // ВАЖНО: мини-превью “как раньше” — всегда пытаемся показать 01.png
  // Если потом вы уже скачали набор, то 01.png всё равно тот же
  const thumbnailUrl = buildSlideUrl(region.id, 1);

  const ornamentFile = `ornament_${region.ornament}.png`;

  item.innerHTML = `
    <div class="card-inner">
      <div class="card-front">
        <div class="license-plate">
          <span class="license-code">${region.code}</span>
        </div>
        <img src="${ornamentFile}" class="region-ornament" alt="${region.name}"
             onerror="this.style.display='none'">
      </div>

      <div class="card-back">
        <img src="${thumbnailUrl}" class="region-thumbnail" alt="${region.name}"
             onerror="this.style.display='none'; this.parentElement.querySelector('.card-status').style.display='block'">
        <div class="card-status" style="display:none;">Нажмите, чтобы открыть</div>
      </div>
    </div>
  `;

  if (forceInactive) {
    grid.appendChild(item);
    return;
  }

  const openHandler = async (e) => {
    if (viewedRegions.has(region.id)) return;

    // 1-й клик — переворот
    if (!item.classList.contains('flipped')) {
      item.classList.add('flipped');
      return;
    }

    // 2-й клик — загрузить (если надо) и открыть
    try {
      await ensureSlidesLoaded(region.id, item);
      // обновляем карточки (если хотите визуально “обновить”)
      createRegionCards();
      openPresentation(region.id);
    } catch (err) {
      console.error(err);
      setCardBackStatus(item, '❌ Не удалось загрузить');
      alert(
        'Не удалось загрузить слайды.\n\n' +
        'Проверьте:\n' +
        '1) Папка региона и регистр букв (Samara ≠ samara)\n' +
        `2) Файлы 01.${SLIDE_EXT}, 02.${SLIDE_EXT} без пропусков\n` +
        '3) Что по прямой ссылке Pages файл открывается\n\n' +
        `Текст: ${err.message || err}`
      );
    }
  };

  item.addEventListener('click', (e) => { e.preventDefault(); openHandler(e); });
  item.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openHandler(e); }
  });

  grid.appendChild(item);
}

function createSplitCard(grid, region, isLeft, cardIndex = 0) {
  const item = document.createElement('div');

  const baseSlot = isLeft ? 'vladivostok' : 'kirov';
  const splitSlot = isLeft ? 'vladivostok-split-left' : 'kirov-split-right';

  item.className = `bento-item ${baseSlot} ${splitSlot} split-card${isFirstLoad ? ' animate-in' : ''}`;
  item.dataset.regionId = region.id;

  if (isFirstLoad) item.style.setProperty('--appear-delay', `${cardIndex * 0.1}s`);

  const isInactive = isLeft; // левую половину делаем “не кликабельной” как у вас было
  if (isInactive || viewedRegions.has(region.id)) item.classList.add('viewed');

  const thumbnailUrl = buildSlideUrl(region.id, 1);
  const ornamentFile = `ornament_${region.ornament}.png`;

  item.innerHTML = `
    <div class="card-inner">
      <div class="card-front">
        <div class="license-plate">
          <span class="license-code">${region.code}</span>
        </div>
        <img src="${ornamentFile}" class="region-ornament" alt="${region.name}"
             onerror="this.style.display='none'">
      </div>

      <div class="card-back">
        <img src="${thumbnailUrl}" class="region-thumbnail" alt="${region.name}"
             onerror="this.style.display='none'; this.parentElement.querySelector('.card-status').style.display='block'">
        <div class="card-status" style="display:none;">Нажмите, чтобы открыть</div>
      </div>
    </div>
  `;

  if (isInactive) {
    grid.appendChild(item);
    return;
  }

  const openHandler = async (e) => {
    if (viewedRegions.has(region.id)) return;

    if (!item.classList.contains('flipped')) {
      item.classList.add('flipped');
      return;
    }

    try {
      await ensureSlidesLoaded(region.id, item);
      createRegionCards();
      openPresentation(region.id);
    } catch (err) {
      console.error(err);
      setCardBackStatus(item, '❌ Не удалось загрузить');
      alert(`Не удалось загрузить слайды для ${region.id}.\n${err.message || err}`);
    }
  };

  item.addEventListener('click', (e) => { e.preventDefault(); openHandler(e); });
  item.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openHandler(e); }
  });

  grid.appendChild(item);
}

/* ========================================
   PRESENTATION VIEW
   ======================================== */
function openPresentation(regionId) {
  if (!hasSlides(regionId)) return;

  currentRegion = regionId;
  currentSlideIndex = 0;

  const container = $('slidesContainer');
  container.innerHTML = '';

  slidesData[regionId].forEach((slide, index) => {
    const img = document.createElement('img');
    img.src = slide.data;
    img.className = 'slide';
    img.alt = `Слайд ${index + 1} из ${slidesData[regionId].length}`;
    if (index === currentSlideIndex) img.classList.add('active');
    container.appendChild(img);
  });

  updateSlideCounter();
  updateNavigationButtons();

  $('presentation')?.classList.add('active');

  viewedRegions.add(regionId);
  updateProgress();
  saveProgressToDB().catch(console.error);
}

function closePresentation() {
  const wasKirov = (currentRegion === kirovRegion.id);

  $('presentation')?.classList.remove('active');
  currentRegion = null;

  saveProgressToDB().catch(console.error);
  createRegionCards();

  if (wasKirov) setTimeout(showFinalScreen, 300);
}

function updateSlideCounter() {
  if (!currentRegion) return;
  const counter = $('slideCounter');
  if (!counter) return;
  counter.textContent = `${currentSlideIndex + 1} / ${slidesData[currentRegion].length}`;
}

function updateNavigationButtons() {
  if (!currentRegion) return;
  const slides = document.querySelectorAll('.slide');
  const prevBtn = document.querySelector('.nav-button.prev');
  const nextBtn = document.querySelector('.nav-button.next');

  if (!prevBtn || !nextBtn) return;

  prevBtn.classList.toggle('disabled', currentSlideIndex === 0);
  nextBtn.classList.toggle('disabled', currentSlideIndex === slides.length - 1);

  prevBtn.setAttribute('aria-disabled', currentSlideIndex === 0 ? 'true' : 'false');
  nextBtn.setAttribute('aria-disabled', currentSlideIndex === slides.length - 1 ? 'true' : 'false');
}

function nextSlide() {
  if (!currentRegion) return;
  const slides = document.querySelectorAll('.slide');
  if (currentSlideIndex >= slides.length - 1) return;

  slides[currentSlideIndex].classList.remove('active');
  currentSlideIndex++;
  slides[currentSlideIndex].classList.add('active');

  updateSlideCounter();
  updateNavigationButtons();
}

function prevSlide() {
  if (!currentRegion) return;
  const slides = document.querySelectorAll('.slide');
  if (currentSlideIndex <= 0) return;

  slides[currentSlideIndex].classList.remove('active');
  currentSlideIndex--;
  slides[currentSlideIndex].classList.add('active');

  updateSlideCounter();
  updateNavigationButtons();
}

/* ========================================
   PROGRESS + SPLIT
   ======================================== */
function updateProgress() {
  const total = getTotalRegionsCount();
  const viewed = viewedRegions.size;
  const pct = Math.min(100, (viewed / total) * 100);

  const fill = $('progressFill');
  const text = $('progressText');
  const bar = document.querySelector('.progress-bar');

  if (fill) fill.style.width = `${pct}%`;
  if (text) text.textContent = `Просмотрено: ${viewed} из ${total} регионов`;
  if (bar) bar.setAttribute('aria-valuenow', String(pct));

  // split включаем, когда все базовые регионы просмотрены
  if (viewedRegions.size >= regions.length && !isSplitMode) {
    setTimeout(splitVladivostokCard, 400);
  }
}

function splitVladivostokCard() {
  if (isSplitMode) return;
  isSplitMode = true;

  // ВАЖНО: ищем по старому CSS-классу, а не по id
  const vladCard = document.querySelector('.bento-item.vladivostok');
  if (vladCard) vladCard.classList.add('splitting');

  setTimeout(() => {
    createRegionCards();
    saveSplitModeToDB().catch(console.error);
    updateProgress();
  }, 700);
}

/* ========================================
   RESET
   ======================================== */
async function resetSlides() {
  if (!confirm('Удалить все загруженные (кэшированные) слайды?')) return;

  slidesData = {};
  const tx = db.transaction(['slides'], 'readwrite');
  const store = tx.objectStore('slides');
  const req = store.clear();

  req.onsuccess = () => createRegionCards();
}

async function resetProgress() {
  if (!confirm('Сбросить прогресс просмотра?')) return;

  viewedRegions.clear();
  isSplitMode = false;

  const tx = db.transaction(['progress'], 'readwrite');
  const store = tx.objectStore('progress');
  const req = store.clear();

  req.onsuccess = () => {
    updateProgress();
    createRegionCards();
    showIntroScreen();
  };
}

/* ========================================
   INTRO SCREEN
   ======================================== */
function showIntroScreen() {
  const intro = $('introScreen');
  if (!intro) return;

  intro.classList.remove('hidden');
  document.body.classList.add('intro-active');

  document.addEventListener('keydown', handleIntroKeyPress);
}

function hideIntroScreen() {
  const intro = $('introScreen');
  if (!intro) return;

  intro.classList.add('hidden');
  document.body.classList.remove('intro-active');

  document.removeEventListener('keydown', handleIntroKeyPress);
}

function handleIntroKeyPress(e) {
  const intro = $('introScreen');
  if (!intro || intro.classList.contains('hidden')) return;

  if (e.key === 'Escape' || e.key === ' ' || e.key === 'Enter') {
    e.preventDefault();
    hideIntroScreen();
  }
}

/* ========================================
   FINAL SCREEN + QR
   ======================================== */
function showFinalScreen() {
  const finalScreen = $('finalScreen');
  if (!finalScreen) return;

  finalScreen.classList.add('active');
  startFlashingWishes();
  startFloatingWishes();
  generateQRCode();
}

function closeFinalScreen() {
  const finalScreen = $('finalScreen');
  if (!finalScreen) return;

  finalScreen.classList.remove('active');
  stopFlashingWishes();
  stopFloatingWishes();

  const bg = $('wishesBackground');
  if (bg) bg.innerHTML = '';
}

function startFlashingWishes() {
  const bg = $('wishesBackground');
  if (!bg) return;

  finalScreenInterval = setInterval(() => {
    const wish = wishesForAnimation[Math.floor(Math.random() * wishesForAnimation.length)];
    const el = document.createElement('div');
    el.className = 'flash-wish';
    el.textContent = wish;
    bg.appendChild(el);
    setTimeout(() => el.remove(), 150);
  }, 200);
}

function stopFlashingWishes() {
  if (finalScreenInterval) {
    clearInterval(finalScreenInterval);
    finalScreenInterval = null;
  }
}

function startFloatingWishes() {
  const bg = $('wishesBackground');
  if (!bg) return;

  for (let i = 0; i < 12; i++) setTimeout(() => createFloatingWish(bg), i * 500);
  floatingWishesInterval = setInterval(() => createFloatingWish(bg), 900);
}

function createFloatingWish(container) {
  const wish = wishesForAnimation[Math.floor(Math.random() * wishesForAnimation.length)];
  const el = document.createElement('div');
  el.className = 'floating-wish';
  el.textContent = wish;

  const startY = Math.random() * 80 + 10;
  const endY = startY + (Math.random() * 20 - 10);
  const duration = 8 + Math.random() * 6;

  el.style.setProperty('--start-y', `${startY}vh`);
  el.style.setProperty('--end-y', `${endY}vh`);
  el.style.setProperty('--float-duration', `${duration}s`);
  el.style.setProperty('--float-delay', '0s');

  container.appendChild(el);
  setTimeout(() => el.remove(), duration * 1000);
}

function stopFloatingWishes() {
  if (floatingWishesInterval) {
    clearInterval(floatingWishesInterval);
    floatingWishesInterval = null;
  }
}

function generateQRCode() {
  const qrContainer = $('qrCode');
  if (!qrContainer) return;

  qrContainer.innerHTML = '';

  const img = document.createElement('img');
  img.src = QR_IMAGE_URL;
  img.alt = 'QR-код для получения пожелания';
  img.style.width = '100%';
  img.style.height = '100%';
  img.style.objectFit = 'contain';

  img.onerror = () => {
    qrContainer.innerHTML = `
      <div style="text-align:center; padding:12px;">
        <div style="margin-bottom:8px;">QR не загрузился</div>
        <div style="font-size:14px; opacity:.85;">
          Откройте ссылку вручную:
          <a href="${WISH_PAGE_URL}" target="_blank" rel="noopener noreferrer">${WISH_PAGE_URL}</a>
        </div>
      </div>
    `;
  };

  qrContainer.appendChild(img);
}

/* ========================================
   STARS / SNOW (если ваши контейнеры есть)
   ======================================== */
function createStars() {
  const container = $('starsContainer');
  if (!container) return;

  const starCount = 120;
  const sizes = ['tiny','tiny','small','small','medium','large'];

  for (let i = 0; i < starCount; i++) {
    const star = document.createElement('div');
    star.className = `star ${sizes[Math.floor(Math.random() * sizes.length)]}`;
    star.style.left = `${Math.random() * 100}%`;
    star.style.top = `${Math.random() * 100}%`;
    star.style.setProperty('--twinkle-duration', `${1.5 + Math.random() * 3}s`);
    star.style.setProperty('--twinkle-delay', `${Math.random() * 3}s`);
    container.appendChild(star);
  }
}

function createSnowflakes() {
  const container = $('snowflakesContainer');
  if (!container) return;

  const count = 50;
  const chars = ['❄','❅','❆','✻','✼','❋'];

  for (let i = 0; i < count; i++) {
    const flake = document.createElement('div');
    flake.className = 'snowflake';
    flake.textContent = chars[Math.floor(Math.random() * chars.length)];
    flake.style.left = `${Math.random() * 100}%`;
    const size = 8 + Math.random() * 18;
    flake.style.setProperty('--snowflake-size', `${size}px`);
    const duration = 8 + Math.random() * 10;
    flake.style.setProperty('--fall-duration', `${duration}s`);
    flake.style.setProperty('--fall-delay', `${Math.random() * 15}s`);
    flake.style.setProperty('--drift', `${-100 + Math.random() * 200}px`);
    flake.style.opacity = 0.5 + Math.random() * 0.5;
    container.appendChild(flake);
  }
}

/* ========================================
   NAVIGATION (keyboard/touch)
   ======================================== */
document.addEventListener('keydown', (e) => {
  const presentationActive = $('presentation')?.classList.contains('active');
  if (!presentationActive) return;

  switch (e.key) {
    case 'ArrowRight':
    case 'ArrowDown':
      e.preventDefault(); nextSlide(); break;
    case 'ArrowLeft':
    case 'ArrowUp':
      e.preventDefault(); prevSlide(); break;
    case 'Escape':
      e.preventDefault(); closePresentation(); break;
  }
});

let touchStartX = 0;
document.addEventListener('touchstart', (e) => {
  const active = $('presentation')?.classList.contains('active');
  if (active) touchStartX = e.changedTouches[0].screenX;
});
document.addEventListener('touchend', (e) => {
  const active = $('presentation')?.classList.contains('active');
  if (!active) return;

  const endX = e.changedTouches[0].screenX;
  const diff = touchStartX - endX;
  if (Math.abs(diff) < 50) return;

  if (diff > 0) nextSlide();
  else prevSlide();
});

/* ========================================
   IMAGE ERROR LOG (не мешает, но помогает)
   ======================================== */
window.addEventListener('error', (e) => {
  if (e.target && e.target.tagName === 'IMG') {
    console.warn('Image failed to load:', e.target.src);
  }
}, true);

/* ========================================
   INIT
   ======================================== */
async function init() {
  try {
    await initDB();
    await loadSlidesFromDB();
    await loadProgressFromDB();
    await loadSplitModeFromDB();

    createRegionCards();
    updateProgress();

    // показываем интро, если оно у вас есть
    // если не нужно — можете убрать showIntroScreen();
    // showIntroScreen();

    console.log('App initialized successfully');
  } catch (err) {
    console.error('Initialization error:', err);
    alert('Ошибка инициализации. Проверьте консоль.');
  }
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    createStars();
    createSnowflakes();
    init();
  });
} else {
  createStars();
  createSnowflakes();
  init();
}

/* ========================================
   Export functions used in HTML buttons
   ======================================== */
window.closePresentation = closePresentation;
window.resetSlides = resetSlides;
window.resetProgress = resetProgress;
window.hideIntroScreen = hideIntroScreen;
window.closeFinalScreen = closeFinalScreen;
window.nextSlide = nextSlide;
window.prevSlide = prevSlide;
