<script>
  // 200 пожеланий (оставьте ваш массив wishes как есть выше)
  // const wishes = [ ... ];

  // Ключ для хранения результата (одно пожелание на устройство)
  const STORAGE_KEY = 'rostelecom_wish_2025_v2';

  // ---------- Утилиты ----------
  function $(id) {
    return document.getElementById(id);
  }

  // Безопасный localStorage: на некоторых устройствах может быть недоступен
  function getStorageSafe() {
    try {
      const t = '__storage_test__';
      window.localStorage.setItem(t, '1');
      window.localStorage.removeItem(t);
      return window.localStorage;
    } catch (e) {
      return null;
    }
  }

  // Неплохой быстрый хэш (FNV-1a 32-bit), устойчивее простого <<5
  function fnv1a32(str) {
    let h = 0x811c9dc5;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
    }
    return h >>> 0;
  }

  // Берём seed из URL (?s=...), если он есть (не обязателен, но поддерживаем)
  function getSeedFromURL() {
    try {
      const params = new URLSearchParams(window.location.search);
      return (params.get('s') || '').trim();
    } catch (e) {
      return '';
    }
  }

  // Генерируем токен один раз (если storage недоступен, токен всё равно поможет выбрать пожелание)
  function generateToken() {
    const rnd = Math.random().toString(36).slice(2);
    const ua = (navigator.userAgent || '').slice(0, 80);
    const ts = Date.now().toString(36);
    return `${ts}.${rnd}.${fnv1a32(ua).toString(36)}`;
  }

  // Вычисляем индекс пожелания
  function pickWishIndex(token, seed) {
    const base = `${token}::${seed}::${wishes.length}`;
    const h = fnv1a32(base);
    return h % wishes.length;
  }

  // Показ пожелания + корректный перезапуск анимации
  function showWishText(text) {
    const wishEl = $('wishText');
    if (!wishEl) return;

    // Убираем спиннер/загрузку: заменяем содержимое целиком
    wishEl.classList.remove('animate');
    wishEl.textContent = text;

    // Перезапуск CSS-анимации
    void wishEl.offsetWidth;
    wishEl.classList.add('animate');
  }

  // Показываем ошибку пользователю (не только в консоль)
  function showError(message) {
    showWishText(`Не удалось показать пожелание. ${message}`);
  }

  // Снежинки (как у вас, но без лишних зависимостей)
  function createSnowflakes() {
    const container = $('snowflakes');
    if (!container) return;

    // чтобы не дублировать снежинки при повторной инициализации
    container.innerHTML = '';

    const chars = ['❄', '❅', '❆', '✻', '✼'];
    const count = 30;

    for (let i = 0; i < count; i++) {
      const flake = document.createElement('div');
      flake.className = 'snowflake';
      flake.textContent = chars[Math.floor(Math.random() * chars.length)];
      flake.style.left = (Math.random() * 100) + '%';
      flake.style.setProperty('--size', (10 + Math.random() * 15) + 'px');
      flake.style.setProperty('--duration', (8 + Math.random() * 10) + 's');
      flake.style.setProperty('--delay', (Math.random() * 10) + 's');
      container.appendChild(flake);
    }
  }

  // Подсказка для скриншота — оставляем, но без “жёстких” сочетаний клавиш
  function saveScreenshot() {
    alert('Сделайте скриншот стандартным способом на вашем телефоне, чтобы сохранить пожелание.');
  }
  // чтобы onclick в HTML работал
  window.saveScreenshot = saveScreenshot;

  // ---------- Основная логика ----------
  function init() {
    try {
      // Валидация массива пожеланий
      if (!Array.isArray(wishes) || wishes.length === 0) {
        showError('Список пожеланий пуст.');
        return;
      }

      createSnowflakes();

      const storage = getStorageSafe();
      const seed = getSeedFromURL();

      // 1) Если уже есть сохранённое — показать сразу
      if (storage) {
        try {
          const raw = storage.getItem(STORAGE_KEY);
          if (raw) {
            const data = JSON.parse(raw);
            if (data && typeof data.wish === 'string' && data.wish.trim()) {
              // Показ почти мгновенно (без раздражающей паузы)
              setTimeout(() => showWishText(data.wish), 120);
              return;
            }
          }
        } catch (e) {
          // битый JSON — игнорируем, пересоздадим
        }
      }

      // 2) Иначе генерируем новое
      const token = generateToken();
      const index = pickWishIndex(token, seed);
      const wish = wishes[index];

      // Показ быстро
      setTimeout(() => showWishText(wish), 180);

      // Сохранение, если возможно
      if (storage) {
        try {
          storage.setItem(STORAGE_KEY, JSON.stringify({
            token,
            seed,
            index,
            wish,
            timestamp: Date.now()
          }));
        } catch (e) {
          // storage может быть переполнен/недоступен — не критично
        }
      }
    } catch (e) {
      console.error(e);
      showError('Попробуйте обновить страницу.');
    }
  }

  document.addEventListener('DOMContentLoaded', init);
</script>
